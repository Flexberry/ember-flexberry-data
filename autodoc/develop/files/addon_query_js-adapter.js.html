<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>addon/query/js-adapter.js - Flexberry Documentation</title>
    <link rel="stylesheet" href="">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="stylesheet" href="../assets/css/custom.css">
    <link rel="stylesheet" href="../assets/vendor/bootstrap/css/bootstrap.css">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
</head>
<body class="yui3-skin-sam">
<div class="navbar navbar-fixed-top">
    <div class="navbar-inner">
        <h1 class="brand" style="padding: 10px 16px 10px; height: 20px; line-height: 20px; margin-left: 0;">
	    <img alt="Flexberry Documentation" src="../assets/css/logo.png" style="max-height: 65%;" title="Flexberry Documentation">
            Flexberry Documentation
        </h1>
	<div class="nav">
            <li class="divider-vertical"></li>
            <li>
                <p class="navbar-text">
                    API Docs for Version: <b>master</b>
                </p>
            </li>
        </div>
        <form class="navbar-form pull-right" style="line-height: 40px; height: 40px;">
            <input style="margin-top: 0;" type="text" class="search-query" placeholder="Search for classes/modules..." data-obj='["classes/Adapter", "classes/Adapter.OData", "classes/Adapter.Offline", "classes/ApplicationInitializer", "classes/Audit", "classes/CopyableMixin", "classes/DecimalTransform", "classes/FileTransform", "classes/FlexberryEnumTransform", "classes/GuidTransform", "classes/OData.OnlineStore", "classes/Offline", "classes/Offline.DexieService", "classes/Offline.GlobalsService", "classes/Offline.LocalStore", "classes/Offline.Model", "classes/Offline.ModelMixin", "classes/Offline.Store", "classes/Offline.Syncer", "classes/Projection", "classes/Projection.AdapterMixin", "classes/Projection.Model", "classes/Projection.ModelWithoutValidation", "classes/Projection.StoreMixin", "classes/Query", "classes/Query.AttributeParam", "classes/Query.BaseAdapter", "classes/Query.BaseBuilder", "classes/Query.BaseParam", "classes/Query.BasePredicate", "classes/Query.Builder", "classes/Query.ComplexPredicate", "classes/Query.Condition", "classes/Query.ConstParam", "classes/Query.DatePredicate", "classes/Query.DetailPredicate", "classes/Query.FalsePredicate", "classes/Query.FilterOperator", "classes/Query.GeographyPredicate", "classes/Query.GeometryPredicate", "classes/Query.IndexedDBAdapter", "classes/Query.IsOfPredicate", "classes/Query.JsAdapter", "classes/Query.NotPredicate", "classes/Query.ODataAdapter", "classes/Query.OrderByClause", "classes/Query.QueryObject", "classes/Query.SimplePredicate", "classes/Query.StringPredicate", "classes/Query.TruePredicate", "classes/Security", "classes/Serializer", "classes/Serializer.Base", "classes/Serializer.OData", "classes/Serializer.Offline", "classes/Utils", "classes/Utils.Information", "modules/ember-flexberry", "modules/ember-flexberry-data"]'>
        </form>
    </div>
</div>
<div class="container">
    <div class="row">
        <div class="span3">
	    <div>
	        <h3>APIs</h3>
	        <div id="sidebar">
	            <ul id="main-nav" class="nav nav-tabs" style="margin-bottom:0;">
	                <li class="active"><a href="#classes" data-toggle="tab">Classes</a></li>
	                <li><a href="#modules" data-toggle="tab">Modules</a></li>
	            </ul>
	    
	            <div id="api-tabview-filter">
	                <input type="search" placeholder="Type to filter APIs">
	            </div>
	    
	            <div class="tab-content" style="border: 1px solid #DDD; border-top:0;">
	                <div class="tab-pane active" id="classes">
	                    <ul id="api-classes" class="nav nav-list">
	                            <li><a href="../classes/Adapter.html">Adapter</a></li>
	                            <li><a href="../classes/Adapter.OData.html">Adapter.OData</a></li>
	                            <li><a href="../classes/Adapter.Offline.html">Adapter.Offline</a></li>
	                            <li><a href="../classes/ApplicationInitializer.html">ApplicationInitializer</a></li>
	                            <li><a href="../classes/Audit.html">Audit</a></li>
	                            <li><a href="../classes/CopyableMixin.html">CopyableMixin</a></li>
	                            <li><a href="../classes/DecimalTransform.html">DecimalTransform</a></li>
	                            <li><a href="../classes/FileTransform.html">FileTransform</a></li>
	                            <li><a href="../classes/FlexberryEnumTransform.html">FlexberryEnumTransform</a></li>
	                            <li><a href="../classes/GuidTransform.html">GuidTransform</a></li>
	                            <li><a href="../classes/Offline.html">Offline</a></li>
	                            <li><a href="../classes/Offline.DexieService.html">Offline.DexieService</a></li>
	                            <li><a href="../classes/Offline.GlobalsService.html">Offline.GlobalsService</a></li>
	                            <li><a href="../classes/Offline.Model.html">Offline.Model</a></li>
	                            <li><a href="../classes/Offline.ModelMixin.html">Offline.ModelMixin</a></li>
	                            <li><a href="../classes/Offline.Store.html">Offline.Store</a></li>
	                            <li><a href="../classes/Offline.Syncer.html">Offline.Syncer</a></li>
	                            <li><a href="../classes/Projection.html">Projection</a></li>
	                            <li><a href="../classes/Projection.AdapterMixin.html">Projection.AdapterMixin</a></li>
	                            <li><a href="../classes/Projection.Model.html">Projection.Model</a></li>
	                            <li><a href="../classes/Projection.ModelWithoutValidation.html">Projection.ModelWithoutValidation</a></li>
	                            <li><a href="../classes/Projection.StoreMixin.html">Projection.StoreMixin</a></li>
	                            <li><a href="../classes/Query.html">Query</a></li>
	                            <li><a href="../classes/Query.AttributeParam.html">Query.AttributeParam</a></li>
	                            <li><a href="../classes/Query.BaseAdapter.html">Query.BaseAdapter</a></li>
	                            <li><a href="../classes/Query.BaseBuilder.html">Query.BaseBuilder</a></li>
	                            <li><a href="../classes/Query.BaseParam.html">Query.BaseParam</a></li>
	                            <li><a href="../classes/Query.BasePredicate.html">Query.BasePredicate</a></li>
	                            <li><a href="../classes/Query.Builder.html">Query.Builder</a></li>
	                            <li><a href="../classes/Query.ComplexPredicate.html">Query.ComplexPredicate</a></li>
	                            <li><a href="../classes/Query.Condition.html">Query.Condition</a></li>
	                            <li><a href="../classes/Query.ConstParam.html">Query.ConstParam</a></li>
	                            <li><a href="../classes/Query.DatePredicate.html">Query.DatePredicate</a></li>
	                            <li><a href="../classes/Query.DetailPredicate.html">Query.DetailPredicate</a></li>
	                            <li><a href="../classes/Query.FalsePredicate.html">Query.FalsePredicate</a></li>
	                            <li><a href="../classes/Query.FilterOperator.html">Query.FilterOperator</a></li>
	                            <li><a href="../classes/Query.GeographyPredicate.html">Query.GeographyPredicate</a></li>
	                            <li><a href="../classes/Query.GeometryPredicate.html">Query.GeometryPredicate</a></li>
	                            <li><a href="../classes/Query.IndexedDBAdapter.html">Query.IndexedDBAdapter</a></li>
	                            <li><a href="../classes/Query.IsOfPredicate.html">Query.IsOfPredicate</a></li>
	                            <li><a href="../classes/Query.JsAdapter.html">Query.JsAdapter</a></li>
	                            <li><a href="../classes/Query.NotPredicate.html">Query.NotPredicate</a></li>
	                            <li><a href="../classes/Query.ODataAdapter.html">Query.ODataAdapter</a></li>
	                            <li><a href="../classes/Query.OrderByClause.html">Query.OrderByClause</a></li>
	                            <li><a href="../classes/Query.QueryObject.html">Query.QueryObject</a></li>
	                            <li><a href="../classes/Query.SimplePredicate.html">Query.SimplePredicate</a></li>
	                            <li><a href="../classes/Query.StringPredicate.html">Query.StringPredicate</a></li>
	                            <li><a href="../classes/Query.TruePredicate.html">Query.TruePredicate</a></li>
	                            <li><a href="../classes/Security.html">Security</a></li>
	                            <li><a href="../classes/Serializer.html">Serializer</a></li>
	                            <li><a href="../classes/Serializer.Base.html">Serializer.Base</a></li>
	                            <li><a href="../classes/Serializer.OData.html">Serializer.OData</a></li>
	                            <li><a href="../classes/Serializer.Offline.html">Serializer.Offline</a></li>
	                            <li><a href="../classes/Utils.html">Utils</a></li>
	                            <li><a href="../classes/Utils.Information.html">Utils.Information</a></li>
	                    </ul>
	                </div>
	    
	                <div class="tab-pane" id="modules">
	                    <ul id="api-modules" class="nav nav-list">
	                            <li><a href="../modules/ember-flexberry.html">ember-flexberry</a></li>
	                            <li><a href="../modules/ember-flexberry-data.html">ember-flexberry-data</a></li>
	                    </ul>
	                </div>
	            </div>
	        </div>
	    </div>
        </div>
        <div class="span9">
                <form id="options-form" class="form-inline pull-right">
                    Show:
                    <label for="api-show-inherited" class="checkbox">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected" class="checkbox">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private" class="checkbox">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated" class="checkbox">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </form>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
<div class="page-header">
    <h1>addon/query/js-adapter.js <small>File</small></h1>
</div>

<div class="file">
    <pre class="prettyprint linenums">
import Ember from &#x27;ember&#x27;;
import BaseAdapter from &#x27;./base-adapter&#x27;;
import {
  SimplePredicate,
  ComplexPredicate,
  StringPredicate,
  DetailPredicate,
  DatePredicate,
  GeographyPredicate,
  GeometryPredicate,
  TruePredicate,
  FalsePredicate
} from &#x27;./predicate&#x27;;
import { ConstParam, AttributeParam } from &#x27;./parameter&#x27;;
import FilterOperator from &#x27;./filter-operator&#x27;;
import Condition from &#x27;./condition&#x27;;
import Information from &#x27;../utils/information&#x27;;

/**
 * Class of query language adapter that translates query object into JS function which
 * filters native JS array of objects by specified logic.
 *
 * &#x60;&#x60;&#x60;js
 * const data = [
 *   { Name: &#x27;A&#x27;, Surname: &#x27;X&#x27;, Age: 10 },
 *   { Name: &#x27;B&#x27;, Surname: &#x27;Y&#x27;, Age: 11 },
 *   { Name: &#x27;B&#x27;, Surname: &#x27;Z&#x27;, Age: 12 }
 * ];
 *
 * let adapter = new JSAdapter(moment);
 * let builder = new QueryBuilder(store, &#x27;AnyUnknownModel&#x27;).where(&#x27;Name&#x27;, FilterOperator.Eq, &#x27;B&#x27;);
 * let filter = adapter.buildFunc(builder.build());
 *
 * let result = filter(data); // Y and Z
 * &#x60;&#x60;&#x60;
 *
 * All filters uses short circuit logic ([wiki](https://en.wikipedia.org/wiki/Short-circuit_evaluation)).
 *
 * @module ember-flexberry-data
 * @namespace Query
 * @class JsAdapter
 * @extends Query.BaseAdapter
 */
export default class JSAdapter extends BaseAdapter {
  /**
    @param {Moment} moment Moment service.
    @class IndexedDBAdapter
    @constructor
  */
  constructor(moment) {
    super();

    if (moment) {
      this._moment = moment;
    }
  }

  /**
   * Builds JS function for filtering JS array of objects by specified logic from query.
   *
   * @method buildFunc
   * @param query Query language instance.
   * @returns {Function} Function for filtering JS array of objects.
   */
  buildFunc(query) {
    let filter = query.predicate ? this.buildFilter(query.predicate) : (data) =&gt; data;
    let order = this.buildOrder(query);
    let projection = this.buildProjection(query);
    let topSkip = this.buildTopSkip(query);
    return function (data) {
      return projection(topSkip(order(filter(data))));
    };
  }

  /**
   * Builds function for windowing array of objects using data from the query.
   *
   * @param {QueryObject} query Query instance.
   * @returns {Function}
   */
  buildTopSkip(query) {
    if (!query.top &amp;&amp; !query.skip) {
      return data =&gt; data;
    }

    return data =&gt; {
      let r = [];
      for (let i = 0; i &lt; data.length; i++) {
        if (i &lt; query.skip) {
          continue;
        }

        r.push(data[i]);

        if (r.length &gt;= query.top) {
          break;
        }
      }

      return r;
    };
  }

  /**
   * Builds function for ordering array of objects using data from the query.
   *
   * @param {QueryObject} query Query instance.
   * @returns {Function}
   */
  buildOrder(query) {
    if (!query.order) {
      return data =&gt; data;
    }

    let desc = (a, b, p) =&gt; {
      let av = this.getValue(a, p);
      let bv = this.getValue(b, p);
      if (av &gt; bv) {
        return -1;
      } else if (av &lt; bv) {
        return 1;
      } else {
        return 0;
      }
    };

    let asc = (a, b, p) =&gt; {
      let av = this.getValue(a, p);
      let bv = this.getValue(b, p);
      if (av &lt; bv) {
        return -1;
      } else if (av &gt; bv) {
        return 1;
      } else {
        return 0;
      }
    };

    return function (data) {
      return data.sort((a, b) =&gt; {
        for (let i = 0; i &lt; query.order.length; i++) {
          let p = query.order.attribute(i);
          let r = p.direction === &#x27;desc&#x27; ? desc(a, b, p.name) : asc(a, b, p.name); // TODO: desc / asc constants
          if (r === 0) {
            continue;
          }

          return r;
        }

        return 0;
      });
    };
  }

  /**
   * Builds function for selecting subset of properties from array of objects using data from the query.
   *
   * @param {QueryObject} query Query instance.
   * @returns {Function}
   */
  buildProjection(query) {
    let select = query.select;
    let expand = query.expand;
    let expandKeys = Object.keys(expand);
    if (!select || select.length === 0) {
      return data =&gt; data;
    }

    return function (data) {
      let dataMap = data.map(item =&gt; {
        let r = {};

        let applySelect = function (r, item, select, exclude) {
          if (!item) {
            return;
          }

          let length = select.length;
          for (let i = 0; i &lt; length; i++) {
            let key = select[i];
            if (exclude.indexOf(key) === -1) {
              r[key] = item[key];
            }
          }
        };

        applySelect(r, item, select, expandKeys);

        let processExpand = function(r, item, expand, expandKeys) {
          if (!expand) {
            return;
          }

          let length = expandKeys.length;
          for (let i = 0; i &lt; length; i++) {
            let expandKey = expandKeys[i];

            let expandItem = expand[expandKey];
            let expandItemSelect = expandItem.select;
            let expandItemExpand = expandItem.expand;
            let expandItemExpandKeys = Object.keys(expandItemExpand);

            if (expandItem.relationship.type === &#x27;belongsTo&#x27;) {
              let itemValue = item[expandKey];
              if (itemValue) {
                // Try to include attr that stores type of relationship for polymorphic master in offline mode.
                // It makes sense only when buildProjection was called from indexeddb-adapter.
                // Otherwise given object always will not contain attr with polymorphic relationship type name.
                if (expandItem.relationship.polymorphic) {
                  let polymorphicMasterTypeKey = &#x27;_&#x27; + expandKey + &#x27;_type&#x27;;
                  if (item.hasOwnProperty(polymorphicMasterTypeKey)) {
                    r[polymorphicMasterTypeKey] = item[polymorphicMasterTypeKey];
                  }
                }

                r[expandKey] = {};
                applySelect(r[expandKey], itemValue, expandItemSelect, expandItemExpandKeys);
                processExpand(r[expandKey], itemValue, expandItemExpand, expandItemExpandKeys);
              } else {
                r[expandKey] = null;
              }
            } else {
              r[expandKey] = [];
              let detailsCount = Ember.isNone(item[expandKey]) ? 0 : item[expandKey].length;
              for (let j = 0; j &lt; detailsCount; j++) {
                let itemValue = item[expandKey][j];
                if (itemValue) {
                  r[expandKey].push({});
                  applySelect(r[expandKey][j], itemValue, expandItemSelect, expandItemExpandKeys);
                  processExpand(r[expandKey][j], itemValue, expandItemExpand, expandItemExpandKeys);
                }
              }
            }
          }
        };

        processExpand(r, item, expand, expandKeys);
        return r;
      });
      return dataMap;
    };
  }

  /**
    Builds function for filtering array of objects using predicate.

    @param {Query.BasePredicate} predicate Predicate for filtering array of objects.
    @param {Object} [options] Object with options for transfer &#x60;getAttributeFilterFunction&#x60; function.
    @return {Function}
  */
  buildFilter(predicate, options) {
    let b1 = predicate instanceof SimplePredicate;
    let b2 = predicate instanceof StringPredicate;
    let b3 = predicate instanceof DetailPredicate;
    let b4 = predicate instanceof DatePredicate;
    let b5 = predicate instanceof GeographyPredicate;
    let b6 = predicate instanceof GeometryPredicate;
    let b7 = predicate instanceof TruePredicate;
    let b8 = predicate instanceof FalsePredicate;
    if (b1 || b2 || b3 || b4 || b7 || b8) {
      let filterFunction = this.getAttributeFilterFunction(predicate, options);
      return this.getFilterFunctionAnd([filterFunction]);
    }

    if (b5) {
      Ember.warn(&#x27;GeographyPredicate is not supported in js-adapter&#x27;);
      return function (data) {
        return data;
      };
    }

    if (b6) {
      Ember.warn(&#x27;GeometryPredicate is not supported in js-adapter&#x27;);
      return function (data) {
        return data;
      };
    }

    if (predicate instanceof ComplexPredicate) {
      let filterFunctions = predicate.predicates.map(predicate =&gt; this.getAttributeFilterFunction(predicate, options));
      switch (predicate.condition) {
        case Condition.And:
          return this.getFilterFunctionAnd(filterFunctions);

        case Condition.Or:
          return this.getFilterFunctionOr(filterFunctions);

        default:
          throw new Error(&#x60;Unsupported condition &#x27;${predicate.condition}&#x27;.&#x60;);
      }
    }

    throw new Error(&#x60;Unsupported predicate &#x27;${predicate}&#x27;&#x60;);
  }

  /**
    Returns function for checkign single object using predicate.

    @param {Query.BasePredicate} predicate Predicate for an attribute.
    @param {Object} [options] Object with options.
    @param {Object} [options.booleanAsString] If this option set as &#x60;true&#x60; and type of &#x60;predicate.value&#x60; equals boolean, convert value to string.
    @returns {Function} Function for checkign single object.
  */
  getAttributeFilterFunction(predicate, options) {
    let _this = this;
    if (!predicate) {
      return (i) =&gt; i;
    }

    if (predicate instanceof SimplePredicate || predicate instanceof DatePredicate) {
      // predicate.attributePath - attribute or AttributeParam or ConstParam.
      // predicate.value - const or AttributeParam or ConstParam.

      return (i) =&gt; {
        let firstOperand = predicate.attributePath;
        let secondOperand = predicate.value;
        let isFirstAttribute = !(firstOperand instanceof ConstParam);
        let isSecondAttribute = secondOperand instanceof AttributeParam;

        let processAttributeFunction = function (attributeOperand, predicate) {
          let realPath = attributeOperand instanceof AttributeParam
                          ? attributeOperand.attributePath
                          : attributeOperand;
          let valueFromHash = _this.getValue(i, realPath);
          let momentFromHash;
          if (predicate instanceof DatePredicate) {
            momentFromHash = _this._moment.moment(valueFromHash);
          }

          // TODO: add support of variant without id.
          let masterValue;
          let isMasterPath = realPath.indexOf(&#x27;.&#x27;, 1) !== -1;
          if (isMasterPath) {
            let masterPath = realPath.slice(0, realPath.lastIndexOf(&#x27;.&#x27;));
            masterValue = _this.getValue(i, masterPath);
          }
          
          return {
            value: valueFromHash,
            momentValue: momentFromHash,
            isMasterPath: isMasterPath,
            masterValue: masterValue
          };
        };

        let processValueFunction = function (constOperand, predicate) {
          let realValue = constOperand instanceof ConstParam
                            ? constOperand.constValue
                            : constOperand;
          let momentValue;
          if (options &amp;&amp; options.booleanAsString &amp;&amp; typeof realValue === &#x27;boolean&#x27;) {
            realValue = &#x60;${realValue}&#x60;;
          }

          if (predicate instanceof DatePredicate) {
            momentValue = _this._moment.moment(realValue);
          }

          return {
            value: realValue,
            momentValue: momentValue
          };
        };

        let firstValue = isFirstAttribute
                          ? processAttributeFunction(firstOperand, predicate)
                          : processValueFunction(firstOperand, predicate);
        
        let secondValue = isSecondAttribute
                          ? processAttributeFunction(secondOperand, predicate)
                          : processValueFunction(secondOperand, predicate);
        
        let datesIsValid = (predicate instanceof DatePredicate) 
                            &amp;&amp; firstValue.momentValue.isValid() &amp;&amp; secondValue.momentValue.isValid();

        let realFirstArgument = datesIsValid ? firstValue.momentValue : firstValue.value;
        let realSecondArgument = secondValue.value;

        let resultPredicate = null;

        switch (predicate.operator) {
          case FilterOperator.Eq:
            resultPredicate = datesIsValid 
                    ? (predicate.timeless ? realFirstArgument.isSame(realSecondArgument, &#x27;day&#x27;) : realFirstArgument.isSame(realSecondArgument))
                    : realFirstArgument === realSecondArgument;
            break;
          case FilterOperator.Neq:
            resultPredicate = datesIsValid 
                    ? (predicate.timeless ? !realFirstArgument.isSame(realSecondArgument, &#x27;day&#x27;) : !realFirstArgument.isSame(realSecondArgument))
                    : realFirstArgument !== realSecondArgument;
            break;
          case FilterOperator.Le:
            resultPredicate = datesIsValid 
                    ? (predicate.timeless ? realFirstArgument.isBefore(realSecondArgument, &#x27;day&#x27;) : realFirstArgument.isBefore(realSecondArgument))
                    : realFirstArgument &lt; realSecondArgument;
            break;
          case FilterOperator.Leq:
            resultPredicate = datesIsValid 
                    ? (predicate.timeless ? realFirstArgument.isSameOrBefore(realSecondArgument, &#x27;day&#x27;) : realFirstArgument.isSameOrBefore(realSecondArgument))
                    : realFirstArgument &lt;= realSecondArgument;
            break;
          case FilterOperator.Ge:
            resultPredicate = datesIsValid 
                    ? (predicate.timeless ? realFirstArgument.isAfter(realSecondArgument, &#x27;day&#x27;) : realFirstArgument.isAfter(realSecondArgument))
                    : realFirstArgument &gt; realSecondArgument;
            break;
          case FilterOperator.Geq:
            resultPredicate = datesIsValid 
                    ? (predicate.timeless ? realFirstArgument.isSameOrAfter(realSecondArgument, &#x27;day&#x27;) : realFirstArgument.isSameOrAfter(realSecondArgument))
                    : realFirstArgument &gt;= realSecondArgument;
            break;
          default:
            throw new Error(&#x60;Unsupported filter operator &#x27;${predicate.operator}&#x27;.&#x60;);
        }

        if (isFirstAttribute &amp;&amp; isSecondAttribute) {
          resultPredicate = (!firstValue.isMasterPath || firstValue.masterValue) 
                            &amp;&amp; (!secondValue.isMasterPath || secondValue.masterValue)
                            &amp;&amp; resultPredicate;
        }

        return resultPredicate;
      };
    }

    if (predicate instanceof StringPredicate) {
      return (i) =&gt; (_this.getValue(i, predicate.attributePath) || &#x27;&#x27;).toLowerCase().indexOf(predicate.containsValue.toLowerCase()) &gt; -1;
    }

    if (predicate instanceof TruePredicate) {
      return () =&gt; true;
    }

    if (predicate instanceof FalsePredicate) {
      return () =&gt; false;
    }

    if (predicate instanceof DetailPredicate) {
      let detailFilter = _this.buildFilter(predicate.predicate, options);
      if (predicate.isAll) {
        return function (i) {
          let detail = _this.getValue(i, predicate.detailPath);
          if (!detail) {
            return false;
          }

          let result = detailFilter(detail);
          return result.length === detail.length;
        };
      } else if (predicate.isAny) {
        return function (i) {
          let detail = _this.getValue(i, predicate.detailPath);
          if (!detail) {
            return false;
          }

          let result = detailFilter(detail);
          return result.length &gt; 0;
        };
      } else {
        throw new Error(&#x60;Unsupported detail operation.&#x60;);
      }
    }

    if (predicate instanceof ComplexPredicate) {
      let filterFunctions = predicate.predicates.map(predicate =&gt; _this.getAttributeFilterFunction(predicate, options));
      switch (predicate.condition) {
        case Condition.And:
          return function (i) {
            let check = true;
            for (let funcIndex = 0; funcIndex &lt; filterFunctions.length; funcIndex++) {
              check &amp;= filterFunctions[funcIndex](i);
              if (!check) {
                break;
              }
            }

            return check;
          };

        case Condition.Or:
          return function (i) {
            let check = false;
            for (let funcIndex = 0; funcIndex &lt; filterFunctions.length; funcIndex++) {
              check |= filterFunctions[funcIndex](i);
              if (check) {
                break;
              }
            }

            return check;
          };

        default:
          throw new Error(&#x60;Unsupported condition &#x27;${predicate.condition}&#x27;.&#x60;);
      }
    }

    throw new Error(&#x60;Unsupported predicate &#x27;${predicate}&#x27;.&#x60;);
  }

  /**
   Loads value from object by specified attribute path.

  @param {Object} item Object for load value.
  @param {String} attributePath The path to the attribute.
  @returns {*|undefined} Value of attribute or &#x60;undefined&#x60;.
  */
  getValue(item, attributePath) {
    let attributes = Information.parseAttributePath(attributePath);
    let search = item;
    for (let i = 0; i &lt; attributes.length; i++) {
      search = search[attributes[i]];
      if (!search) {
        // Don&#x27;t return constant null / undefined - we need to distinguish them.
        return search;
      }

      if (typeof search === &#x27;object&#x27; &amp;&amp; !(search instanceof Array) &amp;&amp; !attributes[i + 1]) {
        // TODO: In fact, it can not only be &#x60;id&#x60;.
        return search.id;
      }
    }

    return search;
  }

  /**
   * Returns complex filter function for &#x60;and&#x60; condition.
   * Result function filters array of objects and returns those, for which
   * all attribute filter functions returned &#x60;true&#x60;.
   * Result function uses short circuit logic ([wiki](https://en.wikipedia.org/wiki/Short-circuit_evaluation)).
   *
   * @param {Function[]} filterFunctions Array of attribute filter functions.
   * @returns {Function} Complex filter function for &#x60;or&#x60; condition.
   */
  getFilterFunctionAnd(filterFunctions) {
    return function (data) {
      let result = [];
      for (let itemIndex = 0; itemIndex &lt; data.length; itemIndex++) {
        let check = true;
        for (let funcIndex = 0; funcIndex &lt; filterFunctions.length; funcIndex++) {
          check &amp;= filterFunctions[funcIndex](data[itemIndex]);
          if (!check) {
            break;
          }
        }

        if (check) {
          result.push(data[itemIndex]);
        }
      }

      return result;
    };
  }

  /**
   * Returns complex filter function for &#x60;or&#x60; condition.
   * Result function filters array of objects and returns those, for which
   * at least one attribute filter function returned &#x60;true&#x60;.
   * Result function uses short circuit logic ([wiki](https://en.wikipedia.org/wiki/Short-circuit_evaluation)).
   *
   * @param {Function[]} filterFunctions Array of attribute filter functions.
   * @returns {Function} Complex filter function for &#x60;or&#x60; condition.
   */
  getFilterFunctionOr(filterFunctions) {
    return function (data) {
      let result = [];
      for (let itemIndex = 0; itemIndex &lt; data.length; itemIndex++) {
        let check = false;
        for (let funcIndex = 0; funcIndex &lt; filterFunctions.length; funcIndex++) {
          check |= filterFunctions[funcIndex](data[itemIndex]);
          if (check) {
            break;
          }
        }

        if (check) {
          result.push(data[itemIndex]);
        }
      }

      return result;
    };
  }
}

    </pre>
</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/jquery/jquery-1.8.2.min.js"></script>
<script src="../assets/vendor/bootstrap/js/bootstrap.js"></script>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script src="../assets/js/yuidoc-bootstrap.js"></script>
<script>prettyPrint();</script>
</body>
</html>
